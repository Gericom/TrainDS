#include <nitro.h>
#include <nnsys/g3d.h>
#include <nnsys/gfd.h>
#include "core.h"
extern "C" 
{
	#include "mb/wh.h"
	#include "mb/mbp.h"
	#include "mb/wfs.h"
}
#include "util.h"
#include "terrain/TerrainManager.h"
#include "menu/TitleMenu.h"
#include "menu/Depot.h"
#include "menu/Game.h"
#include "menu/VideoPlayer.h"

#define	DEFAULT_DMA_NUMBER		1

static const uint8_t mDebugFont[1024] = {
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00
};


static void ExceptionHandler(u32 ptr, void* arg)
{
	((uint16_t*)HW_BG_PLTT)[0] = 0x801F;
	//when we're running on real hardware, we can not simply print
	//We'll load a simple font and show where the problem arose
	GX_SetBankForBG(GX_VRAM_BG_512_ABCD);
	MI_CpuClearFast((void*)HW_BG_VRAM, 512 * 1024);
	MI_DmaCopy32(3, mDebugFont, (void*)HW_BG_VRAM, sizeof(mDebugFont));
	((uint16_t*)HW_PLTT)[0] = 0x8017;
	((uint16_t*)HW_PLTT)[1] = 0xFFFF;
	GX_SetGraphicsMode(GX_DISPMODE_GRAPHICS, GX_BGMODE_1, GX_BG0_AS_2D);
	G2_SetBG3ControlAffine(GX_BG_SCRSIZE_AFFINE_256x256, GX_BG_AREAOVER_XLU, GX_BG_SCRBASE_0x0800, GX_BG_CHARBASE_0x00000);
	MtxFx22 mtx;
	mtx._00 = FX32_ONE;
	mtx._01 = 0;
	mtx._10 = 0;
	mtx._11 = FX32_ONE;
	G2_SetBG3Affine(&mtx, 0, 0, 0, 0);
	GX_SetVisiblePlane(GX_PLANEMASK_BG3);
	GX_DispOn();
	OSContext* context = (OSContext*)ptr;
	uint32_t pc = context->pc_plus4;
	uint32_t lr = context->lr;

	//display lr on first row and pc on second row
	uint16_t* canvas = (uint16_t*)G2_GetBG3ScrPtr();
	//clear canvas
	for (int i = 0; i < 256 * 256 / 2; i++)
	{
		canvas[i] = 0x1010;
	}

	canvas[0] = ((lr >> 28) & 0xF) | (((lr >> 24) & 0xF) << 8);
	canvas[1] = ((lr >> 20) & 0xF) | (((lr >> 16) & 0xF) << 8);
	canvas[2] = ((lr >> 12) & 0xF) | (((lr >> 8) & 0xF) << 8);
	canvas[3] = ((lr >> 4) & 0xF) | (((lr >> 0) & 0xF) << 8);

	canvas[16 + 0] = ((pc >> 28) & 0xF) | (((pc >> 24) & 0xF) << 8);
	canvas[16 + 1] = ((pc >> 20) & 0xF) | (((pc >> 16) & 0xF) << 8);
	canvas[16 + 2] = ((pc >> 12) & 0xF) | (((pc >> 8) & 0xF) << 8);
	canvas[16 + 3] = ((pc >> 4) & 0xF) | (((pc >> 0) & 0xF) << 8);

	//stack trace
	uint32_t* sp = (uint32_t*)context->sp;
	for (int i = 0; i < 29; i++)
	{
		uint32_t val = sp[i];
		canvas[48 + 16 * i + 0] = ((val >> 28) & 0xF) | (((val >> 24) & 0xF) << 8);
		canvas[48 + 16 * i + 1] = ((val >> 20) & 0xF) | (((val >> 16) & 0xF) << 8);
		canvas[48 + 16 * i + 2] = ((val >> 12) & 0xF) | (((val >> 8) & 0xF) << 8);
		canvas[48 + 16 * i + 3] = ((val >> 4) & 0xF) | (((val >> 0) & 0xF) << 8);
	}
	for (int i = 0; i < 29; i++)
	{
		uint32_t val = sp[29 + i];
		canvas[48 + 16 * i + 8 + 0] = ((val >> 28) & 0xF) | (((val >> 24) & 0xF) << 8);
		canvas[48 + 16 * i + 8 + 1] = ((val >> 20) & 0xF) | (((val >> 16) & 0xF) << 8);
		canvas[48 + 16 * i + 8 + 2] = ((val >> 12) & 0xF) | (((val >> 8) & 0xF) << 8);
		canvas[48 + 16 * i + 8 + 3] = ((val >> 4) & 0xF) | (((val >> 0) & 0xF) << 8);
	}

	GX_SetMasterBrightness(0);
	GX_SetVisibleWnd(GX_WNDMASK_NONE);
	G2_BlendNone();
	GX_SetDispSelect(GX_DISP_SELECT_MAIN_SUB);

	NOCASH_Break();
	while (1);
}

void NitroStartUp()
{
	OS_Init();
	Core_PreInit();
}

static void VBlankIntr()
{
	OS_SetIrqCheckFlag(OS_IE_V_BLANK); // checking V-Blank interrupt
}

static void WaitWHState(int state)
{
	while (WH_GetSystemState() != state)
		OS_WaitVBlankIntr();
}

static void* AllocatorForWFS(void *arg, u32 size, void *ptr)
{
	if (!ptr)
	{
		OSIntrMode cur = OS_DisableInterrupts();
		int curHeapGroup = NNS_FndGetGroupIDForExpHeap(gHeapHandle);
		NNS_FndSetGroupIDForExpHeap(gHeapHandle, WFS_HEAP_GROUP_ID);
		void* result = NNS_FndAllocFromExpHeapEx(gHeapHandle, size, 16);
		NNS_FndSetGroupIDForExpHeap(gHeapHandle, curHeapGroup);
		OS_RestoreInterrupts(cur);
		return result;
	}
	else
	{
		NNS_FndFreeToExpHeap(gHeapHandle, ptr);
		return NULL;
	}
}

#include <nitro/code16.h>
static void Init()
{
	TPCalibrateParam calibrate;
	//Done in NitroStartup
	//OS_Init();
	OS_SetUserExceptionHandler(ExceptionHandler, NULL);
	OS_InitTick();
	OS_InitAlarm();//for frame interrupt
	OS_InitVAlarm();
	OS_InitThread();
	TP_Init();
	TP_GetUserInfo(&calibrate);
	TP_SetCalibrateParam(&calibrate);
	GX_Init();
	GX_SetDefaultDMA(2);

	GX_DispOff();
	GXS_DispOff();

	OS_SetIrqFunction(OS_IE_V_BLANK, VBlankIntr);
	OS_EnableIrqMask(OS_IE_V_BLANK);
	OS_EnableIrq();

	FS_Init(DEFAULT_DMA_NUMBER);

	GX_VBlankIntr(true);         // to generate V-Blank interrupt request

	GX_SetBankForLCDC(GX_VRAM_LCDC_ALL);
	MI_CpuClearFast((void *)HW_LCDC_VRAM, HW_LCDC_VRAM_SIZE);
	GX_DisableBankForLCDC();

	MI_CpuFillFast((void *)HW_OAM, 192, HW_OAM_SIZE);   // clear OAM
	MI_CpuClearFast((void *)HW_PLTT, HW_PLTT_SIZE);     // clear the standard palette

	MI_CpuFillFast((void *)HW_DB_OAM, 192, HW_DB_OAM_SIZE);     // clear OAM
	MI_CpuClearFast((void *)HW_DB_PLTT, HW_DB_PLTT_SIZE);       // clear the standard palette

	//CARD_Init();
	//card_lock_id = (u16)OS_GetLockID();

	SND_Init();

	if (MB_IsMultiBootChild())
	{
		WH_Initialize();
		WaitWHState(WH_SYSSTATE_IDLE);
		for (;;)
		{
			/* begins WFS initialization, parent search and connection processes */
			WaitWHState(WH_SYSSTATE_IDLE);
			WFS_InitChild(PORT_WFS, NULL, AllocatorForWFS, NULL);
			WH_SetGgid(WH_GGID);
			WH_ChildConnectAuto(WH_CONNECTMODE_DS_CHILD, (const u8 *)MB_GetMultiBootParentBssDesc()->bssid, 0);
			while ((WH_GetSystemState() == WH_SYSSTATE_BUSY) || (WH_GetSystemState() == WH_SYSSTATE_SCANNING))
				OS_WaitVBlankIntr();
			/* retries when connection fails */
			if (WH_GetSystemState() == WH_SYSSTATE_CONNECT_FAIL)
			{
				WH_Reset();
				WaitWHState(WH_SYSSTATE_IDLE);
			}
			/* end here for unexpected errors */
			else if (WH_GetSystemState() == WH_SYSSTATE_ERROR)
			{
				for (;;)
				{
					static int over_max_entry_count = 0;

					OS_WaitVBlankIntr();

					if (WH_GetLastError() == WM_ERRCODE_OVER_MAX_ENTRY)
					{
						// Retries the connection, considering situations in which a connection is made to a new download child during the timing for a reconnection to the parent child.
						// The real OVER_MAX_ENTRY if it seems the retry will fail.
						if (over_max_entry_count < 10)
						{
							WH_Reset();

							over_max_entry_count++;

							break;
						}
						else
						{
							//PrintString(5, 13, 0xf, "OVER_MAX_ENTRY");
						}
					}
					//PrintString(5, 10, 0x1, "======= ERROR! =======");
				}
			}
			break;
		}
		WaitWHState(WH_SYSSTATE_DATASHARING);
		WFS_Start();
		while (WFS_GetStatus() != WFS_STATE_READY)
			OS_WaitVBlankIntr();
	}

	Core_Init();
	NNS_G3dInit();
	//MIC_Init();
}
#include <nitro/codereset.h>

void OnIntroVideoFinish()
{
	TitleMenu::GotoMenu();
	//Game::GotoMenu();
}

void NitroMain ()
{
	Init();

	OS_WaitVBlankIntr();

	GX_SetMasterBrightness(-16);
	GXS_SetMasterBrightness(-16);
	GX_DispOn();
	GXS_DispOn();

	NNS_FndSetGroupIDForExpHeap(gHeapHandle, MENU_PRIVATE_HEAP_GROUP_ID);//This is to be able to simply free all resources used by the menu after it is closed
	//Game loop
	//Should handle switching menu's and deallocating the shit they didn't (and don't have to) clean up
	//Game::GotoMenu();
	if (!MB_IsMultiBootChild())
		VideoPlayer::GotoMenu("/data/intro.vx2", true, OnIntroVideoFinish);
	else
		TitleMenu::GotoMenu();
	while (gNextMenuCreateFunc)
	{
		NNS_FndSetGroupIDForExpHeap(gHeapHandle, 0);
		gRunningMenu = gNextMenuCreateFunc();
		NNS_FndSetGroupIDForExpHeap(gHeapHandle, MENU_PRIVATE_HEAP_GROUP_ID);
		gNextMenuCreateFunc = NULL;
		int sndHeapState = NNS_SndHeapSaveState(gSndHeapHandle);
		gRunningMenu->Run(gNextMenuArg);
		//restore vblank function (to fix it if it was changed by the menu)
		OS_SetIrqFunction(OS_IE_V_BLANK, VBlankIntr);
		GX_VBlankIntr(true);
		Util_FreeAllToExpHeapByGroupId(gHeapHandle, MENU_PRIVATE_HEAP_GROUP_ID);//Release everything allocated by the menu
		delete gRunningMenu;
		gRunningMenu = NULL;
		//restore sound heap
		NNS_SndHeapLoadState(gSndHeapHandle, sndHeapState);
		//clean up some gfx stuff
		Util_Reset2D();
	}
	while (1)
	{
		OS_WaitVBlankIntr();
	}
}